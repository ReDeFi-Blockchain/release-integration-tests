
name: node-only-update

# Triger: only call from main workflow(re-usable workflows)
on:
  pull_request:
    branches: [ 'main' ]
    types: [ opened, reopened, synchronize, ready_for_review, converted_to_draft ]
  workflow_dispatch:

jobs:
  node-only-update:
    runs-on: [ self-hosted ]
    timeout-minutes: 2880           # 48 hours for execution jobs.
    name: node-only-update
    continue-on-error: true

    steps:
      - name: Skip if pull request is in Draft
        if: github.event.pull_request.draft == true
        run: exit 1

      - name: Clean Workspace
        if: always()
        uses: AutoModality/action-clean@v1.1.0

      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4.1.7
        with:
          ref: ${{ github.head_ref }}  #Checking out head commit

      - name: Read .env file
        uses: xom9ikk/dotenv@v2.3.0

      - name: Pull polkadot image from official repository
        run: |
          docker pull parity/polkadot:v1.7.0

      - name: Prepare relay runtime container
        uses: ./.github/actions/buildContainer
        id: relay-runtime-mainnet
        with:
          container: relay-runtime
          tag: mainnet
          context: .docker
          dockerfile: Dockerfile-relay-runtime
          args: |
            --build-arg L1_RUNTIME_VERSION=${{ env.L1_RUNTIME_MAINNET_VERSION }}          

      - name: Copy runtime wasm file to host
        run: |
          docker run -v $PWD:/infra --rm --entrypoint cp ${{ steps.relay-runtime-mainnet.outputs.name }} /redefi/redefi_runtime.compact.compressed.wasm /infra/
   
      - name: Prepare relay node mainnet container
        uses: ./.github/actions/buildContainer
        id: relay-node-mainnet
        with:
          container: relay-node
          tag: mainnet
          context: .docker
          dockerfile: Dockerfile-relay
          args: |
            --build-arg L1_NODE_VERSION=${{ env.L1_NODE_MAINNET_VERSION }}     

      - name: Prepare relay node target container
        uses: ./.github/actions/buildContainer
        id: relay-node-target
        with:
          container: relay-node
          tag: target
          context: .docker
          dockerfile: Dockerfile-relay
          args: |
            --build-arg L1_NODE_VERSION=${{ env.L1_NODE_TARGET_VERSION }}     

      - name: Prepare parachain mainnet container
        uses: ./.github/actions/buildContainer
        id: parachain-mainnet
        with:
          container: parachain
          tag: mainnet
          context: .docker
          dockerfile: Dockerfile-parachain
          args: |
            --build-arg L2_VERSION=${{ env.L2_MAINNET_VERSION }}     

      - name: Prepare parachain target container
        uses: ./.github/actions/buildContainer
        id: parachain-target
        with:
          container: parachain
          tag: target
          context: .docker
          dockerfile: Dockerfile-parachain
          args: |
            --build-arg L2_VERSION=${{ env.L2_TARGET_VERSION }}     

      - uses: actions/setup-node@v4.0.2
        with:
          node-version: 20

      - name: Install baedeker
        uses: UniqueNetwork/baedeker-action/setup@v1-no-debug-output
        with:
          useCache: false

      - name: Setup library
        run: mkdir -p .baedeker/vendor/ && git clone https://github.com/UniqueNetwork/baedeker-library .baedeker/vendor/baedeker-library

      - name: Start network
        uses: UniqueNetwork/baedeker-action@v1-no-debug-output
        if: success()
        id: bdk
        with:
          jpath: |
            .baedeker/vendor
          tla-str: |
            relay_spec=${{ env.L1_CHAIN_TYPE }}-local            
          inputs: |
            .baedeker/redefi.jsonnet
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/polkadot':{dockerImage:'parity/polkadot:v1.7.0'}})
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-relay':{dockerImage:'${{ steps.relay-node-mainnet.outputs.name }}'}})
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-collator':{dockerImage:'${{ steps.parachain-mainnet.outputs.name }}'}})

      - name: Ensure network is alive
        working-directory: ./tests
        id: alive1
        if: ${{ !cancelled() && steps.bdk.outcome == 'success' }}
        run: |
          yarn        
          ./scripts/wait_for_first_block.sh
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}

      - name: "Reconcile: update only one L2 node"
        uses: UniqueNetwork/baedeker-action/reconcile@v1-no-debug-output
        id: reconcile1
        if: ${{ !cancelled() && steps.alive1.outcome == 'success' }}
        with:
          baedeker: ${{ steps.bdk.outputs.baedeker }}
          # Chain should always be built with the mainnet spec, this we first set binary for all nodes expect one, then set mainnet binary for the last node, and then force chainspec to be still generated from mainnet
          inputs: |
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-collator':{dockerImage:'${{ steps.parachain-target.outputs.name }}'}}, leave = 1, for_chain = false)
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-collator':{dockerImage:'${{ steps.parachain-mainnet.outputs.name }}'}}, for_chain = false)
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-collator':{dockerImage:'${{ steps.parachain-mainnet.outputs.name }}'}})

      - name: Ensure network is alive
        working-directory: ./tests
        id: alive2
        if: ${{ !cancelled() && steps.reconcile1.outcome == 'success' }}
        run: |
          yarn        
          ./scripts/wait_for_first_block.sh
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}

      - name: "Reconcile: all L2 nodes are updated"
        uses: UniqueNetwork/baedeker-action/reconcile@v1-no-debug-output
        id: reconcile2
        if: ${{ !cancelled() && steps.alive2.outcome == 'success' }}
        with:
          baedeker: ${{ steps.bdk.outputs.baedeker }}
          # Chain should always be built with the mainnet spec, this we first set binary for all nodes, and then force chainspec to be still generated from mainnet
          inputs: |
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-collator:{dockerImage:'${{ steps.parachain-target.outputs.name }}'}}, for_chain = false)
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-collator':{dockerImage:'${{ steps.parachain-mainnet.outputs.name }}'}})

      - name: Ensure network is alive
        working-directory: ./tests
        id: alive3
        if: ${{ !cancelled() && steps.reconcile2.outcome == 'success' }}
        run: |
          yarn        
          ./scripts/wait_for_first_block.sh
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}

      - name: "Reconcile: update only one L1 node"
        id: reconcile3
        if: ${{ !cancelled() && steps.alive3.outcome == 'success' }}        
        uses: UniqueNetwork/baedeker-action/reconcile@v1-no-debug-output
        with:
          baedeker: ${{ steps.bdk.outputs.baedeker }}
          # Chain should always be built with the mainnet spec, this we first set binary for all nodes expect one, then set mainnet binary for the last node, and then force chainspec to be still generated from mainnet
          inputs: |
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-relay':{dockerImage:'${{ steps.relay-node-target.outputs.name }}'}}, leave = 1, for_chain = false)
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-relay':{dockerImage:'${{ steps.relay-node-mainnet.outputs.name }}'}}, for_chain = false)
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-relay':{dockerImage:'${{ steps.relay-node-mainnet.outputs.name }}'}})

      - name: Ensure network is alive
        working-directory: ./tests
        id: alive4
        if: ${{ !cancelled() && steps.reconcile3.outcome == 'success' }}
        run: |
          ./scripts/wait_for_first_block.sh
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}

      - name: "Reconcile: all L1 nodes are updated"
        id: reconcile4
        if: ${{ !cancelled() && steps.alive4.outcome == 'success' }}
        uses: UniqueNetwork/baedeker-action/reconcile@v1-no-debug-output
        with:
          baedeker: ${{ steps.bdk.outputs.baedeker }}
          # Chain should always be built with the mainnet spec, this we first set binary for all nodes, and then force chainspec to be still generated from mainnet
          inputs: |
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-relay':{dockerImage:'${{ steps.relay-node-target.outputs.name }}'}}, for_chain = false)
            snippet:(import 'baedeker-library/ops/rewrites.libsonnet').rewriteNodePaths({'bin/redefi-relay':{dockerImage:'${{ steps.relay-node-mainnet.outputs.name }}'}})

      - name: Ensure network is alive
        working-directory: ./tests
        if: ${{ !cancelled() && steps.reconcile4.outcome == 'success' }}
        id: alive5
        run: |
          ./scripts/wait_for_first_block.sh
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}

      - name: Run test:setup for L1 after upgrade
        working-directory: ./tests
        id: test-setup1
        if: ${{ !cancelled() && steps.alive5.outcome == 'success' }}
        run: |
          echo "Ready to start test:setup"
          yarn test:setup 
        env:
          RPC_URL_MAIN: ${{ env.L1_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_L2_HTTP_URL }}
          CROSSCHAIN: true

      - name: Run test:smoke for L1 after upgrade
        working-directory: ./tests
        if: ${{ !cancelled() && steps.test-setup1.outcome == 'success' }}
        run: |
          echo "Ready to start test:smoke"
          yarn test:smoke
        env:
          RPC_URL_MAIN: ${{ env.L1_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_L2_HTTP_URL }}
          CROSSCHAIN: true

      - name: Run test:regular for L1 after upgrade
        working-directory: ./tests
        if: ${{ !cancelled() && steps.test-setup1.outcome == 'success' }}
        run: |
          echo "Ready to start test:regular"
          yarn test:regular
        env:
          RPC_URL_MAIN: ${{ env.L1_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_L2_HTTP_URL }}
          CROSSCHAIN: true

      - name: Run test:serial for L1 after upgrade
        working-directory: ./tests
        if: ${{ !cancelled() && steps.test-setup1.outcome == 'success' }}
        run: |
          echo "Ready to start test:serial"
          yarn test:serial
        env:
          RPC_URL_MAIN: ${{ env.L1_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_L2_HTTP_URL }}
          CROSSCHAIN: true



      - name: Run test:setup for L2 after upgrade
        working-directory: ./tests
        id: test-setup2
        if: ${{ !cancelled() && steps.alive5.outcome == 'success' }}
        run: |
          echo "Ready to start test:setup"
          yarn test:setup 
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_HTTP_URL }}
          CROSSCHAIN: true

      - name: Run test:smoke for L2 after upgrade
        working-directory: ./tests
        if: ${{ !cancelled() && steps.test-setup2.outcome == 'success' }}
        run: |
          echo "Ready to start test:smoke"
          yarn test:smoke
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_HTTP_URL }}
          CROSSCHAIN: true

      - name: Run test:regular for L2 after upgrade
        working-directory: ./tests
        if: ${{ !cancelled() && steps.test-setup2.outcome == 'success' }}
        run: |
          echo "Ready to start test:regular"
          yarn test:regular
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_HTTP_URL }}
          CROSSCHAIN: true

      - name: Run test:serial for L2 after upgrade
        working-directory: ./tests
        if: ${{ !cancelled() && steps.test-setup2.outcome == 'success' }}
        run: |
          echo "Ready to start test:serial"
          yarn test:serial
        env:
          RPC_URL_MAIN: ${{ env.L1_L2_HTTP_URL }}
          RPC_URL_SIBLING: ${{ env.L1_HTTP_URL }}
          CROSSCHAIN: true



      - name: Remove builder cache
        if: always()                   # run this step always
        run: |
          docker system prune -f
